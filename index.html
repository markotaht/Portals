<!DOCTYPE>
<html>
	<head>
		<title>Computer Graphcis - Task 7.2</title>
		<script type="text/javascript" src="three.r81-tweaked.js"></script>
		<script type="text/javascript" src="THREEx.KeyboardState.js"></script>
		<script type="text/javascript">
			
			
			//Muutujad, mingit hetk tuleb üle vaadata
			var renderer, scene, camera, stencilScene;
			var textures = [];
			var bumpTexture; //Store the bump texture in another variable
			var texturesToLoad = 6; //Load a lot of textures
			var textureIndex = 0;
			
			var port1, port2, port1_1,port2_1;
			
			var vertexShader, fragmentShader, fragment2Shader, vertex2Shader;
			
			var lightPosition;
			var light;
			var lightTrajectory;
			
			var port1_cam;
			var port1_quad;
			
			var port2_cam;
			var port2_quad;
			
			var viewerPosition = new THREE.Vector3(0.0, 0.0, 15.0);

			var clock = new THREE.Clock();
			var keyboard = new THREEx.KeyboardState();		


			var wallPos = 20; // seina kaugus 0punktist
			var quadSideLength = 15; // portaali quadi küljepikkus


			function parseControls(dt) {
				if(keyboard.pressed("left")){
					camera.rotation.y += toRad(60 * dt % 360);
				}
				if(keyboard.pressed("right")){
					camera.rotation.y -= toRad(60 * dt % 360);
				}
				if(keyboard.pressed("w")){ // W edasi
					camera.translateZ(-10 * dt % 360);
				}
				if(keyboard.pressed("s")){ // S tagasi
					camera.translateZ(10 * dt % 360);
				}
				if(keyboard.pressed("a")){ // A liigutab vasakule
					camera.translateX(-10 * dt % 360)
				}
				if(keyboard.pressed("d")){ // D liigutab paremale
					camera.translateX(10 * dt % 360)
				}
				if(keyboard.pressed("q")){ // Q liigutab y +
					if (camera.position.y > -wallPos) {
						camera.position.y -= 10 * dt % 360;
					}
				}
				if(keyboard.pressed("e")){ // E liigutab y -
					if (camera.position.y < wallPos) {
						camera.position.y += 10 * dt % 360;
					}		
				}

			}

/*			function millis() {

				return (new Date()).getTime();
			}*/
			
			function toRad(degree) {
			
				return Math.PI * 2 * degree / 360;
			}
		
			function onLoad() { 
				var canvasContainer = document.getElementById('myCanvasContainer'); 
				var width  = 800; 
				var height = 500;
				
				vertexShader    = document.getElementById('vertexShader').textContent;
				fragmentShader  = document.getElementById('fragmentShader').textContent;
				vertex2Shader   = document.getElementById('vertex2Shader').textContent;
				fragment2Shader = document.getElementById('fragment2Shader').textContent;
				
				renderer = new THREE.WebGLRenderer({stencil: true}); 
				renderer.setSize(width, height);
				canvasContainer.appendChild(renderer.domElement);
				renderer.autoClear = false
				
				scene = new THREE.Scene();
				port1_scene = new THREE.Scene();
				port2_scene = new THREE.Scene();
				
				camera = new THREE.PerspectiveCamera(80, width / height, 5, 1000);
				camera.position.set(viewerPosition.x, viewerPosition.y, viewerPosition.z);
				camera.up = new THREE.Vector3(0, 0, -1);
				camera.lookAt(new THREE.Vector3(0,0,0));
			//	scene.add(camera);
			//	camera.rotation.set(0,-Math.PI/2,0)
				
			
				//Valguskera
				scene.add(new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), new THREE.MeshBasicMaterial({color: 0xeeeeee })));
				
				//var object = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), 
				//new THREE.MeshBasicMaterial({color: 0xeeeeee }))
				
				//Vana protaali moodus
				port1_cam = new THREE.PerspectiveCamera(80,1, 1, 1000);	
				port1_cam.position.set(-10, -1, 0);
				port1_cam.up = new THREE.Vector3(0, 1, 0);
				port1_cam.lookAt(new THREE.Vector3(0,0,0));
				port1_cam.updateProjectionMatrix();
				scene.add(port1_cam);

				
				port2_cam = new THREE.PerspectiveCamera(80,1, 1, 1000);
				port2_cam.position.set(10, -1 , 0);
				port2_cam.up = new THREE.Vector3(0, 1, 0);
				port2_cam.lookAt(new THREE.Vector3(0,-3,0));
				port2_cam.updateProjectionMatrix();
				scene.add(port2_cam);
				
				port1 = new THREE.WebGLRenderTarget(width, height, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter});
				port2 = new THREE.WebGLRenderTarget(width, height, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter});
				port1_1 = new THREE.WebGLRenderTarget(width, height, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter});
				port2_1 = new THREE.WebGLRenderTarget(width, height, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter});
				
				
				//Valguse liikumine
				lightTrajectory = new THREE.CatmullRomCurve3([
					new THREE.Vector3(-5, -7, 5 ),
					new THREE.Vector3(-4, -7, -2 ),
					new THREE.Vector3( 3, -7, -4 ),
					new THREE.Vector3( 8, -7, 6 ),
				]);
				lightTrajectory.closed = true;
				light = new THREE.Vector3();
				
				//Objektide loomine ja stseenidesse paigutamine
				addHangar();
				port1_quad = addQuad(port1.texture, -wallPos+0.001,-5,-0.001,Math.PI/2);
				port2_quad = addQuad(port2.texture, wallPos- 0.001, -5,0.001,-Math.PI/2);
				port1_scene.add(port1_quad)
				port2_scene.add(port2_quad)
				
				
				var randomObjects = new THREE.Object3D();
				
				var cube = createCube(0x3DE5CF); //new THREE.Mesh(new THREE.BoxGeometry(4, 4, 4), createShaderMaterial(new THREE.Color(0x3DE5CF)));
				cube.position.set(1, 3, 5);
				cube.scale.set(2, 2, 2);
				randomObjects.add(cube);
				
				var sphere = new THREE.Mesh(new THREE.SphereGeometry(4, 32, 32), createShaderMaterial(new THREE.Color(0xE55B3D)));
				sphere.position.set(-4, -2, 0);
				randomObjects.add(sphere);

				var sphere2 = new THREE.Mesh(new THREE.SphereGeometry(4, 32, 32), createShaderMaterial(new THREE.Color(0x63ef40)));
				sphere2.position.set(2, -15, 1);
				randomObjects.add(sphere2);

				randomObjects.position.set(0, 0, 0);
				scene.add(randomObjects);
				console.log(port1_quad);
				draw();

			}
			
			// Arvutab kaamera vaate(siin on veel migni jama sees, ei tööta kõige paremini)
			function portal_view(camera, src_portal, dst_portal, kordaja) {
				//TODO Kogu see matemaatika siin paneb segast. Leida parem lahendus. 
				//Eesmärk: liigutada kaamera õigesse kohta et portaalist oleks näha õiget objekti.
				//Olemas on kaamera asukoht, protaalide asukohad. Leida nurk ja kaugus port1 ja kaamera vahel
				//Paigutada kaamera port 2 suhtes sama nurga ja kugusega.
				src_portal.updateMatrixWorld()
				dst_portal.updateMatrixWorld()
				camera.updateMatrixWorld()
				
				var camerapos = new THREE.Vector3();
				var camerarot = new THREE.Quaternion();
				var camerascale = new THREE.Vector3();
				
				camera.matrix.decompose(camerapos,camerarot,camerascale);
				var srcportpos = new THREE.Vector3().copy(src_portal.position);
				var srcportrot = new THREE.Vector3().copy(src_portal.rotation);
				var dstportpos = new THREE.Vector3().copy(dst_portal.position);
				var dstportrot = new THREE.Vector3().copy(dst_portal.rotation);
				
				var destquat = new THREE.Quaternion();
				var destpos = new THREE.Vector3();
				var destscale = new THREE.Vector3();
				dst_portal.matrix.decompose(destpos,destquat,destscale);
				
				var diff = srcportpos.sub(camerapos);
			//	diff.applyAxisAngle(new THREE.Vector3(0,1,0), dstportrot.y);
				
				var newcampos = camerapos.add(new THREE.Vector3(40*kordaja, 0,0));
				
				var rot = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI);
			//	camerarot = camerarot.multiply(rot);
				
				var inverse_view_to_source = new THREE.Matrix4();
				inverse_view_to_source.compose(newcampos,camerarot,camerascale);
			//	var inverse_view_to_source = new THREE.Matrix4().getInverse(camera.matrix).multiply(src_portal.matrix);
			//	inverse_view_to_source.makeRotationY(Math.PI);
			//	inverse_view_to_source.elements[0] *= -1;
			//	inverse_view_to_source.elements[10] *= -1;
			//	var rot = new THREE.Matrix4();
			//	rot.makeRotationY(Math.PI);
			//	inverse_view_to_source = dst_portal.matrix.clone().multiply(inverse_view_to_source).multiply(rot);
				//console.log(inverse_view_to_source);
				return inverse_view_to_source;
			}
			
			function addHangar() {
				var hangar = new THREE.Object3D();
				var halfPi = Math.PI / 2;
				//var wallPos = 20;
				var wallSize = 2*wallPos;
				
				var leftWall = createWall(0x47d147, wallSize);
				leftWall.position.set(-wallPos, 0, 0);
				leftWall.rotation.set(0, halfPi, 0);
				hangar.add(leftWall);
				
				var rightWall = createWall(0xff00ff, wallSize);
				rightWall.position.set(wallPos, 0, 0);
				rightWall.rotation.set(0, -halfPi, 0);
				hangar.add(rightWall);
				
				var backWall = createWall(0x1436e1, wallSize);
				backWall.position.set(0, 0, -wallPos);
				hangar.add(backWall);
				
				var ceiling = createWall(0x00ffff, wallSize);
				ceiling.position.set(0, wallPos, 0);
				ceiling.rotation.set(halfPi, 0, 0);
				hangar.add(ceiling);
				
				var floor = createWall(0xffff00, wallSize);
				floor.position.set(0, -wallPos, 0);
				floor.rotation.set(-halfPi, 0, 0);
				hangar.add(floor);
				
				scene.add(hangar);
			}
			
			function draw() {
				requestAnimationFrame(draw);

				var dt = clock.getDelta();

				parseControls(dt);
				
				var time = clock.getElapsedTime();
				var m = time / 4;
				lightPosition = lightTrajectory.getPoint(m - parseInt(m));
				scene.children[0].position.set(lightPosition.x, lightPosition.y, lightPosition.z);
				var temp = new THREE.Vector3().copy(lightPosition).applyMatrix4(camera.matrixWorldInverse);
				light.set(temp.x,temp.y,temp.z);
				
				//console.log(camera.position.y)
				// telepordime kaamera x pos ja quadi piiride järgi
				if (camera.position.x > wallPos-1) {
					if (camera.position.y < port1_quad.position.y + quadSideLength/2 && camera.position.y > port1_quad.position.y - quadSideLength/2 && Math.abs(camera.position.z) < quadSideLength/2) {
						camera.position.x = -wallPos+1;
					}
					else {
						camera.position.x -= 0.25;
					}
				}
				else if (camera.position.x < -wallPos+1) {
					if (camera.position.y < port2_quad.position.y + quadSideLength/2 && camera.position.y > port2_quad.position.y - quadSideLength/2 && Math.abs(camera.position.z) < quadSideLength/2) {
						camera.position.x = wallPos-1;
					}
					else {
						camera.position.x += 0.25;
					}
				}
				// labane kontroll, mis ei lase kaameral hangaarist välja minna
				if (camera.position.z > wallPos) {
					camera.position.z -= 0.25;
				}
				else if (camera.position.z < -wallPos) {
					camera.position.z += 0.25;
				}			
				//Vana renderdus moodus portaalide jaoks
			/*	https://gist.github.com/YenTheFirst/5201821
				
				port1_cam.matrixAutoUpdate = false;
				port1_cam.matrixWorld = portal_view(camera,port1_quad,port2_quad);
				port2_cam.matrixAutoUpdate = false;
				port2_cam.matrixWorld = portal_view(camera,port2_quad,port1_quad);
			*/	
			//	renderer.render(scene,port1_cam,port2);
			/*	port2_quad.material.uniforms.texture.value = port2.texture
				port2_quad.material.needsUpdate = true
				renderer.render(scene,port1_cam,port2_1);
				port2_quad.material.uniforms.texture.value = port2_1.texture
				port2_quad.material.needsUpdate = true
				renderer.render(scene,port2_cam,port1);
				port1_quad.material.uniforms.texture.value = port1.texture
				port1_quad.material.needsUpdate = true
				renderer.render(scene,port2_cam,port1_1);
				port1_quad.material.uniforms.texture.value = port1_1.texture
				port1_quad.material.needsUpdate = true
				*/
				
				
				
			//	renderer.render(scene, camera);
				
				camera.updateMatrixWorld();
				original_mat = camera.matrixWorld.clone();
				
				var gl = renderer.context;
				
				//Puhastame kõik buffrid ära
				renderer.autoClear = false;
				renderer.clear(true,true,true);
				
				//Valmistame stencli
				gl.stencilOp(gl.KEEP,gl.KEEP,gl.REPLACE)
				gl.stencilMask(0xff);
				
				gl.colorMask(false,false,false,false)
				gl.depthMask(false);
				
				gl.enable(gl.STENCIL_TEST)
				gl.enable(gl.DEPTH_TEST)
				
				//Portaal 1 stenclisse
				gl.stencilFunc(gl.ALWAYS,1,0xff)
				renderer.render(port1_scene,camera)
				
				//Portaal 2 stenclisse
				gl.stencilFunc(gl.ALWAYS,2,0xff);
				renderer.render(port2_scene,camera)
				
				renderer.clear(false,true,false)
				
				gl.colorMask(true,true,true,true)
				gl.depthMask(true)
				camera.matrixAutoUpdate = false
				
				//Joonistame esimese protaali vaate
				gl.stencilFunc(gl.EQUAL,1,0xff)
				
				gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP)
				
				camera.matrixWorld.fromArray(portal_view(camera,port1_quad,port2_quad,1).elements)
				var temp = new THREE.Vector3().copy(lightPosition).applyMatrix4(camera.matrixWorldInverse);
				light.set(temp.x,temp.y,temp.z)
				renderer.render(scene,camera)

				//Joonistame teise portaali vaate
				gl.stencilFunc(gl.EQUAL,2,0xff)
				
				gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP)
				camera.matrixWorld = original_mat
				camera.matrixWorld = portal_view(camera,port2_quad,port1_quad,-1)
				var temp = new THREE.Vector3().copy(lightPosition).applyMatrix4(camera.matrixWorldInverse);
				light.set(temp.x,temp.y,temp.z)
				renderer.render(scene,camera)
				
				//Aitab stenclist
				gl.disable(gl.STENCIL_TEST)
				renderer.clear(false,false,true);
				
				//Paneme kaamera tagai algesse kohta
				camera.matrixWorld = original_mat.clone();
				camera.matrixAutoUpdate = true
				
				//Tühjendame sügavuspuhvri
				renderer.clear(false,true,false);
				
				
				//Joonistame mõlemad portaalid sügavus buffrisse
				// Et neid üle ei kirjutataks
				gl.colorMask(false,false,false,false);
				gl.depthMask(true);
				renderer.render(port1_scene,camera)
				renderer.render(port2_scene,camera)
				gl.enable(gl.DEPTH_TEST);
				
			//	camera.matrixAutoUpdate = false;
				//Joonistame lõpliku stseeni
				gl.colorMask(true,true,true,true);
			//	camera.matrixWorld = portal_view(camera,port1_quad,port2_quad,-1)
				renderer.render(scene,camera)
			//	camera.matrixWorld = original_mat
			//	camera.matrixAutoUpdate = true;
				

			}
			
			function teleportCam(portal) {

			}
			function addQuad(texture, x, y, z, roty) {
				var halfPi = Math.PI / 2;
			
				var quad = createQuad(texture);
				quad.position.set(x, y, z);
				quad.rotation.set(0, roty, 0);

				return quad;
			}
			
			function createQuad(texture) {

				var geometry = new THREE.PlaneGeometry(quadSideLength, quadSideLength, 1);
				var material = createTextureMaterial(texture);
				var wall     = new THREE.Mesh(geometry, material);
				
				return wall;
			}
			
			function createWall(colorCode, wallSize) {
				var geometry = new THREE.PlaneGeometry(wallSize, wallSize, 1);
				var color    = new THREE.Color(colorCode);
				var material = createShaderMaterial(color);
				var wall     = new THREE.Mesh(geometry, material);
				
				return wall;
			}
			
			function createCube(colorCode) {
				var geometry = new THREE.BoxGeometry(2, 2, 2);
				var color    = new THREE.Color(colorCode);
				var material = createShaderMaterial(color);
				var cube     = new THREE.Mesh(geometry, material);
				
				return cube;
			}
			
			function createShaderMaterial(color) {
				
				return new THREE.ShaderMaterial({
					uniforms: {
						lightPosition:{
							type: 'v3',
							value: light
						},
						color:{
							value: color
						},
					},
					vertexShader: vertexShader,
					fragmentShader: fragmentShader
				});
			}
			
			function createTextureMaterial(texture) {
			
				return new THREE.ShaderMaterial({
					uniforms: {
						lightPosition:{
							type: 'v3',
							value: light
						},
						texture: {
							type: 't',
							value: texture
						}
					},
					vertexShader: vertex2Shader,
					fragmentShader: fragment2Shader
				});
			}
			
		</script>
		<script id="vertexShader" type="x-shader/x-vertex">
			varying vec3 interpolatedPosition;
			varying vec3 interpolatedNormal;
			
			void main() {
				interpolatedPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
				interpolatedNormal = normalMatrix * normal;
				
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
			}
		</script>
		<script id="fragmentShader" type="x-shader/x-fragment">
			uniform vec3 lightPosition;
			
			varying vec3 interpolatedPosition;
			varying vec3 interpolatedNormal;
			
			uniform vec3 color;
			void main() {
				vec3 viewerPosition = vec3(0.0);
			
				vec3 n = normalize(interpolatedNormal);
				vec3 l = normalize(lightPosition - interpolatedPosition);
				vec3 v = normalize(viewerPosition - interpolatedPosition);
				
				vec3 r = normalize(reflect(-l,n));
				float shininess = 200.0;
				
				vec3 interpolatedColor = color* vec3(0.1) + color* max(0.0,dot(n,l)) + pow(max(0.0,dot(v,r)),shininess); 
				gl_FragColor = vec4(interpolatedColor, 1.0);
			}
		</script>
		<script id="vertex2Shader" type="x-shader/x-vertex">
			varying vec2 interpolatedUv;
			
			void main() {
				interpolatedUv = uv;
				
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
			}
		</script>
		<script id="fragment2Shader" type="x-shader/x-fragment">
			varying vec2 interpolatedUv;
			
			uniform sampler2D texture;
			
			void main() {
			
				
				vec3 color = texture2D(texture, interpolatedUv).rgb; 
				gl_FragColor = vec4(color, 1.0);
			}
	</script>
	</head>
	<body onload="onLoad()">
		<div id="myCanvasContainer"></div>
		<div id="statusContainer"></div>
	</body>
</html>